Front,Back,Extra,Tags
"Your web application needs to execute background tasks triggered by HTTP requests but complete asynchronously. Tasks may run for up to 10 minutes. The solution must minimize infrastructure management and costs.<br><br>A) Azure App Service WebJobs with continuous execution<br>B) Azure Functions with Durable Functions extension<br>C) Azure Container Instances with REST API trigger","B) Azure Functions with Durable Functions extension","Durable Functions orchestrate long-running workflows with built-in state management, automatic retries, and checkpointing. Supports async HTTP APIs with status polling. WebJobs require App Service plan (always running). ACI lacks native workflow orchestration. Durable Functions is serverless and purpose-built for stateful workflows.","AZ-204 Compute AzureFunctions"
"An application must scale to 1000 concurrent users with <100ms response time. Traffic is unpredictable with usage spikes during business hours. The solution must minimize costs during off-hours.<br><br>A) Azure App Service with Premium V3 plan and autoscale rules<br>B) Azure Functions Consumption plan with HTTP trigger<br>C) Azure Container Apps with KEDA autoscaling","C) Azure Container Apps with KEDA autoscaling","Container Apps provides automatic scale-to-zero, KEDA-based scaling, and microservices-optimized hosting. Functions Consumption has 230-second timeout (insufficient for some requests). App Service Premium doesn't scale to zero. Container Apps balances serverless economics with container flexibility for web workloads.","AZ-204 Compute Containers"
"A Function App processes messages from a Service Bus queue. During high volume, poison messages cause repeated failures. The solution must move failed messages after 5 attempts without losing data.<br><br>A) Configure Service Bus queue with dead-letter queue and maxDeliveryCount=5<br>B) Implement try-catch in function code with retry logic<br>C) Use Application Insights to track failures and manual intervention","A) Configure Service Bus queue with dead-letter queue and maxDeliveryCount=5","Service Bus automatically moves messages to DLQ after maxDeliveryCount exceeded, preserving message metadata and enabling later analysis/reprocessing. Manual retry logic is error-prone and couples business logic with error handling. App Insights monitors but doesn't handle messages. DLQ is the platform pattern for poison message handling.","AZ-204 Messaging ServiceBus"
"Your Azure Function must authenticate to Azure SQL Database without credentials in code. The function uses a system-assigned managed identity. Connection strings are managed centrally.<br><br>A) Store connection string with password in Key Vault, retrieve using managed identity<br>B) Use managed identity token in SQL connection string with Azure AD authentication<br>C) Store credentials in Function App application settings encrypted","B) Use managed identity token in SQL connection string with Azure AD authentication","Managed identity with SQL Azure AD auth eliminates credentials entirely - connection string uses Authentication=Active Directory Managed Identity. Option A still has passwords in Key Vault. Option C stores credentials (encrypted but present). Managed identity to SQL auth is credential-free pattern for Azure compute.","AZ-204 Security ManagedIdentity"
"An API must securely store database connection strings, API keys, and certificates with automatic rotation every 90 days and audit logging of all access attempts.<br><br>A) Azure Key Vault with secret versioning and access policies<br>B) Azure App Configuration with Key Vault references<br>C) Application settings with encryption at rest","A) Azure Key Vault with secret versioning and access policies","Key Vault is purpose-built for secrets management with versioning, automatic rotation via integrations, and comprehensive audit logs. App Configuration is for settings (use Key Vault references for secrets). Application settings lack rotation features and granular auditing. Key Vault is the secure secrets store with governance features.","AZ-204 Security KeyVault"
"A web application must retrieve feature flags and configuration values with <50ms latency. Configuration changes must propagate to all app instances within 30 seconds without redeployment.<br><br>A) Azure App Configuration with push refresh and feature management<br>B) Azure Key Vault with application polling<br>C) Environment variables with configuration reload","A) Azure App Configuration with push refresh and feature management","App Configuration provides dynamic configuration with push refresh (Event Grid notifications), feature flags with targeting, and built-in caching for low latency. Key Vault is for secrets not config. Environment variables require app restart. App Configuration is the dynamic config management service with sub-second propagation.","AZ-204 Configuration AppConfiguration"
"Your containerized application must scale from 0 to 100 instances based on Azure Service Bus queue length with Kubernetes-compatible APIs. The solution must minimize operational overhead.<br><br>A) Azure Kubernetes Service with KEDA scaler<br>B) Azure Container Instances with Azure Logic App trigger<br>C) Azure Container Apps with Service Bus scale rule","C) Azure Container Apps with Service Bus scale rule","Container Apps has built-in KEDA scaling with Service Bus queue depth trigger, scales to zero, and is fully managed (no cluster management). AKS requires cluster operations. ACI doesn't autoscale natively by queue depth. Container Apps provides KEDA scaling without Kubernetes operational complexity.","AZ-204 Compute Containers"
"An application stores 500GB of JSON documents queried by user ID and timestamp. Queries must support complex filters and global distribution across 3 regions with <10ms P99 read latency.<br><br>A) Azure Cosmos DB for NoSQL with composite indexes<br>B) Azure SQL Database with JSON columns and geo-replication<br>C) Azure Table Storage with geo-redundant storage","A) Azure Cosmos DB for NoSQL with composite indexes","Cosmos DB provides automatic global distribution with <10ms reads, multi-region writes, and composite indexes for efficient JSON queries. SQL Database geo-replication is async (higher latency). Table Storage lacks complex query capabilities. Cosmos DB is the globally distributed NoSQL database optimized for JSON with SLA-backed latency.","AZ-204 Storage CosmosDB"
"Your application must upload 10,000 images per hour to Blob Storage with optimized throughput and automatic retry on transient failures. Images vary from 100KB to 5MB.<br><br>A) Azure Storage SDK with BlobClient and parallel upload operations<br>B) REST API with PUT Blob calls<br>C) AzCopy command-line tool in application code","A) Azure Storage SDK with BlobClient and parallel upload operations","Storage SDK provides built-in retry policies, parallel uploads for large blobs, and optimized throughput with block upload. REST API requires manual retry logic. AzCopy is for command-line scenarios not application integration. SDK abstracts complexity with best practices (exponential backoff, parallelization) built-in.","AZ-204 Storage BlobStorage"
"A blob storage solution must support versioning with automatic deletion of old versions after 30 days while preserving current versions indefinitely. The solution must minimize storage costs.<br><br>A) Enable blob versioning with lifecycle management policy to delete non-current versions after 30 days<br>B) Use blob snapshots with scheduled Azure Function cleanup<br>C) Enable soft delete with 30-day retention","A) Enable blob versioning with lifecycle management policy to delete non-current versions after 30 days","Blob versioning automatically maintains previous versions, lifecycle management has noncurrentVersionsToDelete action for retention policies. Snapshots require manual management. Soft delete protects against deletion but doesn't manage version retention. Versioning + lifecycle = automated version lifecycle with cost optimization.","AZ-204 Storage BlobStorage"
"Your API must implement caching for product catalog queries with 5-minute TTL and support for tag-based cache invalidation when products update. Cache must be shared across multiple app instances.<br><br>A) Azure Cache for Redis with SET commands and tag-based eviction<br>B) In-memory caching with IMemoryCache per instance<br>C) Azure SQL Database query results caching","A) Azure Cache for Redis with SET commands and tag-based eviction","Redis provides distributed caching shared across instances, TTL support, and tag-based eviction via SET data structures or key patterns. In-memory caching is per-instance (not shared). SQL query caching lacks flexible invalidation. Redis is the distributed cache for multi-instance applications with advanced eviction strategies.","AZ-204 Optimization Caching"
"An Azure Function must process Event Grid events from Blob Storage with guaranteed delivery and manual checkpoint control for batch processing. Processing may take up to 5 minutes per batch.<br><br>A) Event Grid trigger with default settings<br>B) Azure Blob Storage trigger with polling<br>C) Event Hubs output binding from Event Grid with Event Hubs trigger","C) Event Hubs output binding from Event Grid with Event Hubs trigger","Event Grid webhook has 60-second timeout (insufficient). Blob trigger uses polling (delay). Event Grid can output to Event Hubs, then Event Hubs trigger provides checkpoint control and longer processing time. This pattern buffers Event Grid events through Event Hubs for reliable long-running processing with manual checkpoints.","AZ-204 Messaging EventGrid"
"Your application must implement authentication using Azure AD with support for personal Microsoft accounts and social identity providers. Users should consent to permissions on first sign-in.<br><br>A) Microsoft Identity Platform with microsoft.com/consumers endpoint<br>B) Azure AD B2C with custom policies<br>C) Azure AD with guest user invitations","A) Microsoft Identity Platform with microsoft.com/consumers endpoint","Microsoft Identity Platform supports both organizational (AAD) and personal accounts (MSA) via /common or /consumers endpoints, built-in consent framework. B2C is for customer identity with more customization (overkill). Guest invitations are for B2B scenarios. Identity Platform is the unified auth solution for consumer + enterprise apps.","AZ-204 Security Authentication"
"A REST API must validate JWT tokens from Azure AD, check for specific application roles, and deny requests without valid tokens. The solution must minimize custom code.<br><br>A) Azure API Management with validate-jwt policy and check-claim policy<br>B) Application middleware with manual JWT validation<br>C) Azure Front Door with Azure AD authentication","A) Azure API Management with validate-jwt policy and check-claim policy","APIM validate-jwt policy verifies token signature, expiration, and audience declaratively. Check-claim policy validates roles/scopes. This is declarative security without code. Manual validation is error-prone. Front Door doesn't have JWT validation policies. APIM centralizes API security with policy-based token validation.","AZ-204 Security APIM"
"Your application must retrieve secrets from Key Vault with automatic retry on throttling errors and caching of secrets for 1 hour to minimize Key Vault requests and costs.<br><br>A) Azure SDK for Key Vault with DefaultAzureCredential and custom caching logic<br>B) REST API calls to Key Vault with manual cache implementation<br>C) Azure App Configuration Key Vault references","A) Azure SDK for Key Vault with DefaultAzureCredential and custom caching logic","Key Vault SDK with DefaultAzureCredential provides automatic authentication (managed identity in Azure), built-in retry policies for throttling. Add caching layer to reduce calls. Option C uses App Configuration as proxy (adds latency). REST API requires manual retry logic. SDK + caching = resilient secret retrieval with cost optimization.","AZ-204 Security KeyVault"
"An Azure Function triggered by HTTP must return immediately with 202 Accepted and process work asynchronously with status polling endpoint. Processing may take 10 minutes with potential retries.<br><br>A) Durable Functions with async HTTP pattern<br>B) Synchronous function with Task.Run for background work<br>C) Queue output binding with separate function for processing","A) Durable Functions with async HTTP pattern","Durable Functions async HTTP returns 202 with status/cancel/terminate URLs automatically, orchestrates long-running workflows with retries and checkpoints. Task.Run blocks worker threads. Queue pattern requires manual status tracking. Durable Functions implements async HTTP API pattern with built-in state management and status endpoints.","AZ-204 Compute AzureFunctions"
"Your API must implement rate limiting with 1000 requests per minute per user and return HTTP 429 with Retry-After header when exceeded. The solution must work across multiple API instances.<br><br>A) Azure API Management with rate-limit-by-key policy using subscription key<br>B) Application code with distributed cache counter<br>C) Azure Front Door with rate limiting rules","A) Azure API Management with rate-limit-by-key policy using subscription key","APIM rate-limit-by-key policy enforces limits across all gateway instances, automatically returns 429 with Retry-After header. Supports various keys (subscription, IP, JWT claim). Option B requires custom implementation. Front Door rate limiting is IP-based only. APIM provides declarative, distributed rate limiting with user-based keys.","AZ-204 Security APIM"
"A container application must run scheduled jobs every hour with automatic scaling to zero between runs and support for long job executions up to 2 hours.<br><br>A) Azure Container Apps with cron scale rule<br>B) Azure Functions with timer trigger<br>C) Azure Container Instances with Logic App scheduler","A) Azure Container Apps with cron scale rule","Container Apps supports cron scale rules (scale to zero when idle, scale up on schedule), no execution time limits. Functions timer has 230-second timeout (Consumption) or requires Premium/Dedicated for longer. ACI doesn't autoscale. Container Apps provides serverless containers with cron scheduling and unlimited execution time.","AZ-204 Compute Containers"
"Your application must store order data with guaranteed ACID transactions across multiple document types and partition keys. Queries require SQL-like syntax with JOIN operations.<br><br>A) Azure Cosmos DB for NoSQL with transactional batch and subquery support<br>B) Azure Cosmos DB with stored procedures for transactions<br>C) Azure SQL Database with JSON columns","A) Azure Cosmos DB for NoSQL with transactional batch and subquery support","Cosmos DB transactional batch supports multi-document ACID within same partition, SQL API supports JOINs within documents and subqueries. Stored procedures can cross partitions but complex. SQL Database is relational (not document). Cosmos DB provides NoSQL with ACID guarantees and SQL query capabilities for document data.","AZ-204 Storage CosmosDB"
"An API must securely expose backend services with request transformation, response caching, and OAuth 2.0 token validation without modifying backend code.<br><br>A) Azure API Management with policies for transformation, caching, and JWT validation<br>B) Azure Application Gateway with WAF<br>C) Azure Functions Proxies with custom middleware","A) Azure API Management with policies for transformation, caching, and JWT validation","APIM provides declarative policies for request/response transformation, caching, JWT validation, rate limiting - all without backend changes. App Gateway is L7 load balancer (limited transformation). Functions Proxies deprecated. APIM is the API gateway with comprehensive policy framework for API management concerns.","AZ-204 APIM APIManagement"
"Your Function App must process messages from an Azure Storage Queue with automatic scaling based on queue depth and exponential backoff retry on failures with maximum 5 attempts.<br><br>A) Azure Functions with Queue trigger and host.json configuration for maxDequeueCount and backoff<br>B) Manual polling with SDK and custom retry logic<br>C) Logic App with Storage Queue connector","A) Azure Functions with Queue trigger and host.json configuration for maxDequeueCount and backoff","Queue trigger automatically scales based on queue depth, host.json maxDequeueCount moves to poison queue after retries, batchSize controls throughput. Built-in exponential backoff for transient failures. Manual polling requires custom scaling. Logic Apps add cost overhead for compute workloads. Functions is the native queue processing compute with built-in patterns.","AZ-204 Compute AzureFunctions"
"An application must emit custom metrics (business KPIs like orders processed) to Azure Monitor for dashboard visualization and threshold-based alerting with <1 minute latency.<br><br>A) Application Insights with TrackMetric() and metric alerts<br>B) Log Analytics custom logs with log query alerts<br>C) Event Hubs with Stream Analytics aggregation","A) Application Insights with TrackMetric() and metric alerts","Application Insights custom metrics (TrackMetric) support near-real-time ingestion, metric alerts provide <1 min granularity, native dashboard integration. Log query alerts have higher latency (>1 min). Event Hubs streaming adds complexity. App Insights is the APM platform for custom business metrics with fast alerting.","AZ-204 Monitoring ApplicationInsights"
"Your web application must handle file uploads up to 500MB with progress reporting, resume capability on failure, and parallelized upload for optimal throughput.<br><br>A) Azure Blob Storage SDK with block blob upload in chunks and BlockBlobClient.StageBlockAsync<br>B) HTTP multipart form upload to API, then copy to Storage<br>C) Azure Data Factory copy activity","A) Azure Blob Storage SDK with block blob upload in chunks and BlockBlobClient.StageBlockAsync","Block blobs support chunked upload (StageBlockAsync), parallelization, resume capability (track uploaded blocks), and progress reporting. Upload via API doubles bandwidth. Data Factory is for ETL not application uploads. Block blob staging is the optimized pattern for large file uploads with fault tolerance.","AZ-204 Storage BlobStorage"
"A microservices application must implement distributed tracing across 15 services with automatic correlation of requests, dependency mapping, and anomaly detection without code changes to existing services.<br><br>A) Application Insights with auto-instrumentation and distributed tracing<br>B) Custom logging with correlation IDs<br>C) Azure Monitor Logs with manual telemetry","A) Application Insights with auto-instrumentation and distributed tracing","Application Insights auto-instrumentation (agents/extensions) captures telemetry without code changes, distributed tracing uses W3C Trace Context for correlation, application map shows dependencies, smart detection finds anomalies. Custom logging requires manual correlation. App Insights is the zero-code APM solution with distributed tracing.","AZ-204 Monitoring ApplicationInsights"
"Your API must implement circuit breaker pattern with 50% failure threshold over 10 seconds, open circuit for 30 seconds, then half-open to test recovery without custom code.<br><br>A) Azure API Management with circuit breaker backend policy (preview)<br>B) Polly library in application code<br>C) Azure Front Door with health probes","A) Azure API Management with circuit breaker backend policy (preview)","APIM circuit breaker policy implements pattern declaratively with configurable thresholds, intervals, and half-open state. Polly requires code (acceptable but adds dependencies). Front Door health probes are for routing not circuit breaking. APIM externalizes resilience patterns from application code with policy-based circuit breaker.","AZ-204 Optimization APIM"
"A Function App must authenticate users via Microsoft Identity Platform, validate access tokens, and extract user claims for authorization. The solution must minimize custom security code.<br><br>A) Azure Functions with built-in authentication (Easy Auth) and ClaimsPrincipal binding<br>B) Manual JWT validation with jose-jwt library<br>C) Azure API Management JWT validation in front of Functions","A) Azure Functions with built-in authentication (Easy Auth) and ClaimsPrincipal binding","Easy Auth handles OAuth flow, validates tokens, and injects ClaimsPrincipal into function context automatically. No custom validation code needed. Manual JWT validation is complex. APIM validation works but adds layer. Easy Auth is the built-in function identity platform integration with zero security code.","AZ-204 Security Authentication"
"Your application must store telemetry data with partition key by deviceId and sort by timestamp. Expected 100,000 writes/sec with 99.99% availability and automatic global replication to 5 regions.<br><br>A) Azure Cosmos DB for NoSQL with multi-region writes and partition key on deviceId<br>B) Azure Table Storage with geo-redundant replication<br>C) Azure SQL Database with auto-failover groups","A) Azure Cosmos DB for NoSQL with multi-region writes and partition key on deviceId","Cosmos DB scales horizontally for 100K writes/sec, multi-region writes (active-active), 99.99% SLA, automatic global replication. Table Storage can't handle this write throughput. SQL Database limited by instance size. Cosmos DB is the globally distributed database for high-throughput time-series with multi-region writes.","AZ-204 Storage CosmosDB"
"An API must transform XML requests to JSON before forwarding to backend, add custom headers, and mask sensitive response data without changing backend services.<br><br>A) Azure API Management with policies: xml-to-json, set-header, and find-replace<br>B) Azure Functions proxy with custom code<br>C) Azure Logic Apps with XML and JSON actions","A) Azure API Management with policies: xml-to-json, set-header, and find-replace","APIM policies provide declarative transformation (xml-to-json), header manipulation (set-header), content masking (find-replace) without backend changes. Functions Proxies deprecated. Logic Apps add latency and cost for API scenarios. APIM is the API gateway with rich transformation policies for mediation layer.","AZ-204 APIM APIManagement"
"Your containerized application must support blue-green deployments with traffic splitting (90% to stable, 10% to new version) and automatic rollback if error rate exceeds 1%.<br><br>A) Azure Container Apps with revisions and traffic splitting rules<br>B) Azure Kubernetes Service with Ingress traffic splitting<br>C) Azure App Service with deployment slots","A) Azure Container Apps with revisions and traffic splitting rules","Container Apps supports multiple revisions with percentage-based traffic splitting, ingress configuration for routing. Can monitor and adjust traffic based on metrics. AKS requires manual Ingress configuration. App Service slots work but blue-green not traffic splitting. Container Apps provides managed revision-based deployments with traffic control.","AZ-204 Compute Containers"
"A Function App must securely connect to on-premises SQL Server via hybrid connection, retrieve data, and return results. The on-premises network restricts inbound traffic.<br><br>A) Azure Functions Premium plan with VNet Integration and VPN Gateway<br>B) Azure Functions Consumption plan with Hybrid Connections<br>C) Azure App Service with VNet Integration and ExpressRoute","B) Azure Functions Consumption plan with Hybrid Connections","Hybrid Connections (Consumption compatible) create outbound-only tunnel to on-premises without VPN or VNet changes. Premium plan VNet Integration requires VPN/ExpressRoute. Option C is App Service (not Functions). Hybrid Connections provide simplified hybrid connectivity for Functions without network infrastructure changes.","AZ-204 Compute AzureFunctions"
"Your application must implement SAS token generation for blob access with 1-hour validity, read-only permissions, and IP restrictions to corporate network range without exposing storage account keys.<br><br>A) User delegation SAS signed with Azure AD credentials via managed identity<br>B) Account SAS signed with storage account key<br>C) Service SAS with stored access policy","A) User delegation SAS signed with Azure AD credentials via managed identity","User delegation SAS uses Azure AD credentials (managed identity) instead of account keys, supports all SAS features (time, permissions, IP). Account SAS requires key exposure. Service SAS with policy still uses account key. User delegation SAS provides key-less SAS generation with Azure AD authentication.","AZ-204 Storage BlobStorage"
"An event-driven architecture must process order events with guaranteed at-least-once delivery, message deduplication, and automatic dead-lettering after 5 retries.<br><br>A) Azure Service Bus topic with duplicate detection and maxDeliveryCount<br>B) Azure Event Hubs with consumer checkpointing<br>C) Azure Event Grid with retry policy","A) Azure Service Bus topic with duplicate detection and maxDeliveryCount","Service Bus provides duplicate detection (message ID based), automatic dead-lettering (maxDeliveryCount), and at-least-once with PeekLock. Event Hubs is streaming (no DLQ). Event Grid lacks duplicate detection. Service Bus is the enterprise messaging service with deduplication and poison message handling for reliable event processing.","AZ-204 Messaging ServiceBus"
"Your API must cache responses for 10 minutes based on query parameters with cache invalidation on POST/PUT/DELETE requests to related resources. Cache must be shared across instances.<br><br>A) Azure API Management with cache-lookup and cache-store policies with vary-by query parameters<br>B) Azure CDN for dynamic content caching<br>C) Azure Cache for Redis with custom cache-aside pattern","A) Azure API Management with cache-lookup and cache-store policies with vary-by query parameters","APIM caching policies provide vary-by (query params, headers), automatic cache invalidation on mutations, distributed cache across gateway instances. CDN is for static/edge content. Redis cache-aside requires code. APIM declarative caching optimizes API responses without backend changes.","AZ-204 Optimization APIM"
"A background job must process 1 million records from Cosmos DB with parallel execution across 10 workers, checkpoint progress every 1000 records, and support resume after failure.<br><br>A) Azure Functions with Cosmos DB change feed trigger and lease collection<br>B) Azure Batch with custom Cosmos DB query<br>C) Durable Functions with activity fan-out","A) Azure Functions with Cosmos DB change feed trigger and lease collection","Change feed trigger automatically distributes work across function instances, lease collection manages checkpoints per partition, supports resume from last checkpoint. Azure Batch requires manual processing logic. Durable fan-out doesn't checkpoint per partition. Change feed is the native parallel Cosmos DB processing pattern with built-in checkpointing.","AZ-204 Storage CosmosDB"
"Your application must retrieve feature flags with real-time updates, A/B testing support with user targeting, and integration with Application Insights for telemetry without polling.<br><br>A) Azure App Configuration with feature flags and push refresh model<br>B) LaunchDarkly third-party service<br>C) Database table with application polling","A) Azure App Configuration with feature flags and push refresh model","App Configuration feature management supports targeting (users, groups, percentage), push refresh via Event Grid (no polling), native App Insights integration for telemetry. LaunchDarkly works but adds external dependency. Database polling adds latency. App Configuration is the Azure-native dynamic config with feature management and push updates.","AZ-204 Configuration AppConfiguration"
"An application must handle bursts of 10,000 events per second with event filtering based on event type and routing to different handlers. Event order is not critical.<br><br>A) Azure Event Grid with custom topics and event subscription filters<br>B) Azure Service Bus with topic filters<br>C) Azure Event Hubs with consumer groups","A) Azure Event Grid with custom topics and event subscription filters","Event Grid handles 10M events/sec, supports subject/data filtering in subscriptions, push-based delivery to multiple handlers. Service Bus optimized for <100K msgs/sec. Event Hubs requires consumers to filter. Event Grid is the high-scale event routing service with declarative filtering and fan-out.","AZ-204 Messaging EventGrid"
"Your API must implement versioning with support for v1 and v2 simultaneously, route based on header/query parameter, and deprecated version warnings without URL path changes.<br><br>A) Azure API Management with version sets and revision management<br>B) Separate API endpoints with manual routing<br>C) Application code with if-else version checking","A) Azure API Management with version sets and revision management","APIM version sets support multiple versions with routing by header/query param, deprecation warnings, unified management. Separate endpoints fragment API. Code-based versioning couples routing with business logic. APIM centralizes API versioning strategy with flexible routing and lifecycle management.","AZ-204 APIM APIManagement"
"A Function App must execute code in response to blob upload with automatic processing of new files within 1 second and guaranteed ordering per blob container.<br><br>A) Event Grid trigger with Blob Storage events and serial processing per container<br>B) Blob Storage trigger with polling interval<br>C) Queue trigger with blob notification","A) Event Grid trigger with Blob Storage events and serial processing per container","Event Grid provides near-real-time blob events (<1 sec), guaranteed delivery. Configure single function instance per container for ordering. Blob trigger uses polling (10 sec+ delay). Queue notification requires manual wiring. Event Grid blob events offer lowest latency triggering with event-driven architecture.","AZ-204 Compute AzureFunctions"
"Your application must implement authentication with both Azure AD organizational accounts and social providers (Google, Facebook) for a consumer-facing application with customizable sign-in UI.<br><br>A) Azure AD B2C with custom policies and identity providers<br>B) Microsoft Identity Platform with /common endpoint<br>C) Azure AD with B2B guest accounts","A) Azure AD B2C with custom policies and identity providers","B2C is purpose-built for consumer identity with social IDP federation, custom branding/UI, sign-up/sign-in flows. Identity Platform /common supports MSA but not social. B2B is for business partners. B2C provides comprehensive CIAM (Customer Identity Access Management) with social identity and customization.","AZ-204 Security Authentication"
"An API must implement request throttling with different limits per pricing tier (Basic: 100/min, Premium: 1000/min) and return proper HTTP status codes with retry guidance.<br><br>A) Azure API Management with rate-limit policy and product subscriptions<br>B) Application code with distributed counter<br>C) Azure Front Door with custom rules","A) Azure API Management with rate-limit policy and product subscriptions","APIM products define pricing tiers with different rate limits per product, rate-limit policy enforces limits with 429 responses and Retry-After headers. Custom code requires maintenance. Front Door doesn't support tier-based limiting. APIM monetization features provide declarative tier-based API access control.","AZ-204 APIM APIManagement"